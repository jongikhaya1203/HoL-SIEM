<?php
/**
 * Vulnerability Scanner Class
 * Performs comprehensive vulnerability assessment
 * Implements CVSS scoring and risk prioritization per Gartner recommendations
 */

require_once __DIR__ . '/Database.php';

class VulnerabilityScanner {
    private $db;
    private $checks = [];

    public function __construct() {
        $this->db = Database::getInstance();
        $this->initializeChecks();
    }

    /**
     * Initialize vulnerability checks
     */
    private function initializeChecks() {
        $this->checks = [
            'weak_protocols' => [$this, 'checkWeakProtocols'],
            'outdated_services' => [$this, 'checkOutdatedServices'],
            'default_credentials' => [$this, 'checkDefaultCredentials'],
            'ssl_tls_security' => [$this, 'checkSSLTLSSecurity'],
            'information_disclosure' => [$this, 'checkInformationDisclosure'],
            'missing_security_headers' => [$this, 'checkSecurityHeaders'],
            'open_databases' => [$this, 'checkOpenDatabases'],
            'anonymous_access' => [$this, 'checkAnonymousAccess']
        ];
    }

    /**
     * Scan host for vulnerabilities
     */
    public function scanHost($hostId, $hostData, $ports) {
        $vulnerabilities = [];

        foreach ($this->checks as $checkName => $checkFunction) {
            $results = call_user_func($checkFunction, $hostData, $ports);
            if (!empty($results)) {
                $vulnerabilities = array_merge($vulnerabilities, $results);
            }
        }

        // Store vulnerabilities in database
        foreach ($vulnerabilities as $vuln) {
            $this->storeVulnerability($hostId, $vuln);
        }

        return $vulnerabilities;
    }

    /**
     * Check for weak/insecure protocols
     */
    private function checkWeakProtocols($hostData, $ports) {
        $vulnerabilities = [];
        $weakPorts = [
            21 => ['protocol' => 'FTP', 'issue' => 'Unencrypted file transfer'],
            23 => ['protocol' => 'TELNET', 'issue' => 'Unencrypted remote access'],
            80 => ['protocol' => 'HTTP', 'issue' => 'Unencrypted web traffic'],
            139 => ['protocol' => 'NetBIOS', 'issue' => 'Legacy protocol with security issues'],
            445 => ['protocol' => 'SMB', 'issue' => 'Potential for ransomware attacks']
        ];

        foreach ($ports as $port) {
            if ($port['state'] === 'open' && isset($weakPorts[$port['port']])) {
                $info = $weakPorts[$port['port']];
                $vulnerabilities[] = [
                    'port' => $port['port'],
                    'title' => "Insecure Protocol: {$info['protocol']}",
                    'description' => "Port {$port['port']} is running {$info['protocol']}. {$info['issue']}.",
                    'severity' => 'medium',
                    'cvss_score' => 5.3,
                    'recommendation' => "Disable {$info['protocol']} and use encrypted alternatives (e.g., SFTP instead of FTP, SSH instead of Telnet, HTTPS instead of HTTP)."
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Check for outdated services with known vulnerabilities
     */
    private function checkOutdatedServices($hostData, $ports) {
        $vulnerabilities = [];

        foreach ($ports as $port) {
            if ($port['state'] === 'open' && !empty($port['service_name']) && !empty($port['version'])) {
                // Check against vulnerability database
                $vulns = $this->checkServiceVulnerabilities($port['service_name'], $port['version']);
                foreach ($vulns as $vuln) {
                    $vuln['port'] = $port['port'];
                    $vulnerabilities[] = $vuln;
                }
            }
        }

        return $vulnerabilities;
    }

    /**
     * Check for default credentials
     */
    private function checkDefaultCredentials($hostData, $ports) {
        $vulnerabilities = [];
        $defaultCredPorts = [
            22 => 'SSH',
            3306 => 'MySQL',
            5432 => 'PostgreSQL',
            27017 => 'MongoDB',
            6379 => 'Redis',
            3389 => 'RDP'
        ];

        foreach ($ports as $port) {
            if ($port['state'] === 'open' && isset($defaultCredPorts[$port['port']])) {
                $service = $defaultCredPorts[$port['port']];
                $vulnerabilities[] = [
                    'port' => $port['port'],
                    'title' => "Potential Default Credentials - {$service}",
                    'description' => "Service {$service} detected on port {$port['port']}. Default credentials may be in use.",
                    'severity' => 'high',
                    'cvss_score' => 7.5,
                    'recommendation' => "Verify that default credentials are not in use. Implement strong password policies and consider key-based authentication."
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Check SSL/TLS security
     */
    private function checkSSLTLSSecurity($hostData, $ports) {
        $vulnerabilities = [];

        foreach ($ports as $port) {
            if ($port['state'] === 'open' && in_array($port['port'], [443, 465, 993, 995, 8443])) {
                // Check for SSL certificate issues
                if (isset($port['ssl_info'])) {
                    if ($port['ssl_info']['expired'] ?? false) {
                        $vulnerabilities[] = [
                            'port' => $port['port'],
                            'title' => 'Expired SSL Certificate',
                            'description' => 'SSL certificate has expired. Valid until: ' . ($port['ssl_info']['valid_to'] ?? 'unknown'),
                            'severity' => 'high',
                            'cvss_score' => 7.4,
                            'recommendation' => 'Renew SSL certificate immediately.'
                        ];
                    }

                    // Check for self-signed certificates
                    if (strpos($port['ssl_info']['issuer'] ?? '', 'self-signed') !== false) {
                        $vulnerabilities[] = [
                            'port' => $port['port'],
                            'title' => 'Self-Signed SSL Certificate',
                            'description' => 'SSL certificate is self-signed, which can be vulnerable to MITM attacks.',
                            'severity' => 'medium',
                            'cvss_score' => 5.9,
                            'recommendation' => 'Use a certificate from a trusted Certificate Authority.'
                        ];
                    }
                }
            }
        }

        return $vulnerabilities;
    }

    /**
     * Check for information disclosure
     */
    private function checkInformationDisclosure($hostData, $ports) {
        $vulnerabilities = [];

        foreach ($ports as $port) {
            if ($port['state'] === 'open' && !empty($port['banner'])) {
                $banner = $port['banner'];

                // Check for version disclosure
                if (preg_match('/(Apache|nginx|PHP|MySQL)\/[\d.]+/i', $banner)) {
                    $vulnerabilities[] = [
                        'port' => $port['port'],
                        'title' => 'Version Information Disclosure',
                        'description' => 'Service banner reveals version information that could aid attackers.',
                        'severity' => 'low',
                        'cvss_score' => 3.7,
                        'recommendation' => 'Configure services to hide version information in banners.'
                    ];
                }
            }
        }

        return $vulnerabilities;
    }

    /**
     * Check for missing security headers (HTTP services)
     */
    private function checkSecurityHeaders($hostData, $ports) {
        $vulnerabilities = [];

        foreach ($ports as $port) {
            if ($port['state'] === 'open' && in_array($port['port'], [80, 443, 8080, 8443])) {
                if (!empty($port['banner'])) {
                    $banner = strtolower($port['banner']);
                    $missingHeaders = [];

                    if (strpos($banner, 'x-frame-options') === false) {
                        $missingHeaders[] = 'X-Frame-Options';
                    }
                    if (strpos($banner, 'x-content-type-options') === false) {
                        $missingHeaders[] = 'X-Content-Type-Options';
                    }
                    if (strpos($banner, 'strict-transport-security') === false && $port['port'] === 443) {
                        $missingHeaders[] = 'Strict-Transport-Security (HSTS)';
                    }
                    if (strpos($banner, 'content-security-policy') === false) {
                        $missingHeaders[] = 'Content-Security-Policy';
                    }

                    if (!empty($missingHeaders)) {
                        $vulnerabilities[] = [
                            'port' => $port['port'],
                            'title' => 'Missing Security Headers',
                            'description' => 'The following security headers are missing: ' . implode(', ', $missingHeaders),
                            'severity' => 'medium',
                            'cvss_score' => 5.3,
                            'recommendation' => 'Implement recommended security headers to protect against common web vulnerabilities.'
                        ];
                    }
                }
            }
        }

        return $vulnerabilities;
    }

    /**
     * Check for open database ports
     */
    private function checkOpenDatabases($hostData, $ports) {
        $vulnerabilities = [];
        $dbPorts = [
            3306 => 'MySQL',
            5432 => 'PostgreSQL',
            1433 => 'MSSQL',
            27017 => 'MongoDB',
            6379 => 'Redis',
            9200 => 'Elasticsearch'
        ];

        foreach ($ports as $port) {
            if ($port['state'] === 'open' && isset($dbPorts[$port['port']])) {
                $db = $dbPorts[$port['port']];
                $vulnerabilities[] = [
                    'port' => $port['port'],
                    'title' => "Publicly Accessible Database - {$db}",
                    'description' => "{$db} database is accessible from the network on port {$port['port']}. This poses a security risk.",
                    'severity' => 'high',
                    'cvss_score' => 7.5,
                    'recommendation' => "Restrict database access to authorized hosts only. Use firewall rules or bind to localhost. Implement authentication and encryption."
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Check for anonymous access
     */
    private function checkAnonymousAccess($hostData, $ports) {
        $vulnerabilities = [];

        foreach ($ports as $port) {
            if ($port['state'] === 'open') {
                // Check FTP anonymous login
                if ($port['port'] === 21 && !empty($port['banner'])) {
                    if (strpos(strtolower($port['banner']), 'anonymous') !== false) {
                        $vulnerabilities[] = [
                            'port' => 21,
                            'title' => 'FTP Anonymous Access Enabled',
                            'description' => 'FTP server allows anonymous access.',
                            'severity' => 'high',
                            'cvss_score' => 7.5,
                            'recommendation' => 'Disable anonymous FTP access and require authentication.'
                        ];
                    }
                }

                // Check for open SMB shares
                if ($port['port'] === 445) {
                    $vulnerabilities[] = [
                        'port' => 445,
                        'title' => 'SMB Service Exposed',
                        'description' => 'SMB/CIFS service is exposed to the network, which is frequently targeted by ransomware.',
                        'severity' => 'high',
                        'cvss_score' => 7.8,
                        'recommendation' => 'Disable SMB if not needed. If required, ensure latest patches are applied and restrict access via firewall.'
                    ];
                }
            }
        }

        return $vulnerabilities;
    }

    /**
     * Check service against vulnerability database
     */
    private function checkServiceVulnerabilities($serviceName, $version) {
        $sql = "SELECT * FROM vulnerabilities
                WHERE affected_services LIKE ?
                AND (affected_versions LIKE ? OR affected_versions IS NULL)
                ORDER BY cvss_score DESC";

        $results = $this->db->fetchAll($sql, [
            "%{$serviceName}%",
            "%{$version}%"
        ]);

        $vulnerabilities = [];
        foreach ($results as $vuln) {
            $vulnerabilities[] = [
                'cve_id' => $vuln['cve_id'],
                'title' => $vuln['title'],
                'description' => $vuln['description'],
                'severity' => $vuln['severity'],
                'cvss_score' => $vuln['cvss_score'],
                'recommendation' => 'Update ' . $serviceName . ' to the latest version. See: ' . ($vuln['external_references'] ?? 'N/A')
            ];
        }

        return $vulnerabilities;
    }

    /**
     * Store vulnerability in database
     */
    private function storeVulnerability($hostId, $vulnData) {
        // First, check if vulnerability exists in vulnerabilities table
        $sql = "SELECT id FROM vulnerabilities WHERE title = ? LIMIT 1";
        $existing = $this->db->fetchOne($sql, [$vulnData['title']]);

        if (!$existing) {
            // Insert new vulnerability
            $sql = "INSERT INTO vulnerabilities (cve_id, title, description, severity, cvss_score, affected_services)
                    VALUES (?, ?, ?, ?, ?, ?)";
            $this->db->query($sql, [
                $vulnData['cve_id'] ?? null,
                $vulnData['title'],
                $vulnData['description'],
                $vulnData['severity'],
                $vulnData['cvss_score'],
                $vulnData['service_name'] ?? null
            ]);
            $vulnerabilityId = $this->db->lastInsertId();
        } else {
            $vulnerabilityId = $existing['id'];
        }

        // Get scan_id and port_id
        $hostInfo = $this->db->fetchOne("SELECT scan_id FROM hosts WHERE id = ?", [$hostId]);

        $portId = null;
        if (isset($vulnData['port'])) {
            $portInfo = $this->db->fetchOne(
                "SELECT id FROM ports WHERE host_id = ? AND port_number = ?",
                [$hostId, $vulnData['port']]
            );
            $portId = $portInfo['id'] ?? null;
        }

        // Insert scan result
        $sql = "INSERT INTO scan_results (scan_id, host_id, port_id, vulnerability_id, evidence, status)
                VALUES (?, ?, ?, ?, ?, 'open')";
        $this->db->query($sql, [
            $hostInfo['scan_id'],
            $hostId,
            $portId,
            $vulnerabilityId,
            $vulnData['recommendation'] ?? null
        ]);
    }

    /**
     * Calculate overall risk score for a host
     */
    public function calculateRiskScore($vulnerabilities) {
        if (empty($vulnerabilities)) {
            return 0;
        }

        $totalScore = 0;
        $weights = [
            'critical' => 10.0,
            'high' => 7.5,
            'medium' => 5.0,
            'low' => 2.5,
            'info' => 0.5
        ];

        foreach ($vulnerabilities as $vuln) {
            $severity = $vuln['severity'] ?? 'low';
            $totalScore += $weights[$severity] ?? 0;
        }

        // Normalize to 0-10 scale
        $riskScore = min(10, $totalScore / count($vulnerabilities));

        return round($riskScore, 2);
    }
}
